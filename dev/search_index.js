var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = Thunks","category":"page"},{"location":"#Thunks","page":"Home","title":"Thunks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Thunks.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Thunks]\nOrder   = [:function, :type, :macro]","category":"page"},{"location":"#Thunks._find_symbols_in_ast-Tuple{Any}","page":"Home","title":"Thunks._find_symbols_in_ast","text":"Return either (nothing, List[Expr]), (Symbol, nothing), or (nothing, nothing).\n\nHelper function following cons and nil pattern from Lisp.\n\n\n\n\n\n","category":"method"},{"location":"#Thunks._thunkify","page":"Home","title":"Thunks._thunkify","text":"Helper function to dispatch based on Expr head.\n\n\n\n\n\n","category":"function"},{"location":"#Thunks._thunkify_eq","page":"Home","title":"Thunks._thunkify_eq","text":"Assign left of = to a thunk.\n\n\n\n\n\n","category":"function"},{"location":"#Thunks._thunkify_expr","page":"Home","title":"Thunks._thunkify_expr","text":"Actually create the Thunk struct.\n\nWrap expression in anonymous function, with each assigned symbol as an arg.\n\n\n\n\n\n","category":"function"},{"location":"#Thunks.find_assigned_symbols_in_ast-Tuple{Any}","page":"Home","title":"Thunks.find_assigned_symbols_in_ast","text":"We find all \"assigned symbols\", as in, everything except:\n\nanonymous functions :((x,y,z) -> x*x).args[1]\ngenerators :((x for x in 1:10))\nReserved keywords\n... others that we should catch...?\n\n\n\n\n\n","category":"method"},{"location":"#Thunks.find_symbols_in_ast-Tuple{Any}","page":"Home","title":"Thunks.find_symbols_in_ast","text":"Walk an AST and find all unique symbols.\n\n\n\n\n\n","category":"method"},{"location":"#Thunks.maybe_thunk-Tuple{Any, Any}","page":"Home","title":"Thunks.maybe_thunk","text":"Return true if symbol could be assigned to a Thunk.\n\n\n\n\n\n","category":"method"},{"location":"#Thunks.noop-Tuple","page":"Home","title":"Thunks.noop","text":"No operation.\n\n\n\n\n\n","category":"method"},{"location":"#Thunks.thunkify","page":"Home","title":"Thunks.thunkify","text":"Rewrite expression for lazy evaluation using thunks. Not intended for public usage.\n\n\n\n\n\n","category":"function"},{"location":"#Thunks.thunkify_block","page":"Home","title":"Thunks.thunkify_block","text":"Rewrite a begin...end block to be lazy.\n\n\n\n\n\n","category":"function"},{"location":"#Thunks.undo-Tuple{Reversible}","page":"Home","title":"Thunks.undo","text":"Undo function call (non-recursively)\n\n\n\n\n\n","category":"method"},{"location":"#Thunks.undo-Tuple{Thunks.WrappedThink}","page":"Home","title":"Thunks.undo","text":"Undo function call (non-recursively)\n\n\n\n\n\n","category":"method"},{"location":"#Thunks.Checkpointable","page":"Home","title":"Thunks.Checkpointable","text":"A Thunk that can be checkpointed.\n\n\n\n\n\n","category":"type"},{"location":"#Thunks.Reversible","page":"Home","title":"Thunks.Reversible","text":"A Thunk that can \"undo\" code evaluation. Does not clear f or args.\n\nUseful for interactive coding. ie if you revise a function definition, can undo & reify the thunk again.\n\n\n\n\n\n","category":"type"},{"location":"#Thunks.Think","page":"Home","title":"Thunks.Think","text":"Abstract type for Thunks.\n\n\n\n\n\n","category":"type"},{"location":"#Thunks.Thunk","page":"Home","title":"Thunks.Thunk","text":"Thunk(function, args, kwargs)\n\nType that represents a thunk. Only evaluated is a public field. Use reify to evaluate. Evaluates to Weak head normal form, meaning that non-free symbols must be assigned / defined. Contrast with Unevaluated.\n\n\n\n\n\n","category":"type"},{"location":"#Thunks.Unevaluated","page":"Home","title":"Thunks.Unevaluated","text":"Keep expression, including args/kwargs, as unevaluated.\n\n\n\n\n\n","category":"type"},{"location":"#Thunks.@lazy-Tuple{Any}","page":"Home","title":"Thunks.@lazy","text":"@lazy <Expr>\n\nLazy evaluation of arbitrary expressions.\n\n@lazy x+y\n@lazy x = f(y)\n@lazy begin\n    a = 1\n    b = 2\n    c = 3\n    abc = sum([a,b,c])\nend\nreify(abc)\n# output\n6\n\n\n\n\n\n","category":"macro"},{"location":"#Thunks.@noeval-Tuple{Any}","page":"Home","title":"Thunks.@noeval","text":"@noeval <Expr>\n\nLazy evaluation of arbitrary expressions that does not check for variable definition. This is safe to use if the assumption of referential transprency holds, and should be used with extreme caution otherwise, e.g. if referenced variables might be mutated. Note that evaluation occurs in the scope of where reify is called.\n\n@noeval begin\n    # will not error\n    not_used = not_defined + 1\n    a = 1\n    b = 2\n    c = 3\n    abc = sum([a,b,c])\nend\nc = -1\nreify(abc)\n# output\n2\n\n\n\n\n\n","category":"macro"},{"location":"#Thunks.@reversible-Tuple{Any}","page":"Home","title":"Thunks.@reversible","text":"@reversible <Expr>\n\nLazy evaluation of arbitrary expressions that allows for computation to be undone.\n\n@reversible begin\n    a = 1\n    b = 2\n    c = 3\n    abc = sum([a,b,c])\nend\n@assert abc.evaluated == false\nreify(abc)\n@assert abc.evaluated == true\nundo(abc)\n@assert abc.evaluated == false\nreify(abc)\n@assert abc.evaluated == true\n# output\n\n\n\n\n\n\n","category":"macro"}]
}
