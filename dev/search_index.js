var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = Thunks","category":"page"},{"location":"#Thunks","page":"Home","title":"Thunks","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Thunks.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [Thunks]","category":"page"},{"location":"#Thunks.Thunk","page":"Home","title":"Thunks.Thunk","text":"Thunk(function, args, kwargs)\n\nType that represents a thunk. Only evaluated is a public field. Use reify to evaluate.\n\n\n\n\n\n","category":"type"},{"location":"#Thunks._find_symbols_in_ast-Tuple{Any}","page":"Home","title":"Thunks._find_symbols_in_ast","text":"Return either (nothing, List[Expr]), (Symbol, nothing), or (nothing, nothing).\n\nHelper function following cons and nil pattern from Lisp.\n\n\n\n\n\n","category":"method"},{"location":"#Thunks._thunkify_expr-Tuple{Any}","page":"Home","title":"Thunks._thunkify_expr","text":"Wrap expression in anonymous function, with each assigned symbol as an arg.\n\n\n\n\n\n","category":"method"},{"location":"#Thunks.find_assigned_symbols_in_ast-Tuple{Any}","page":"Home","title":"Thunks.find_assigned_symbols_in_ast","text":"We find all \"assigned symbols\", as in, everything except:\n\nanonymous functions :((x,y,z) -> x*x).args[1]\ngenerators :((x for x in 1:10))\n... others that we should catch...?\n\n\n\n\n\n","category":"method"},{"location":"#Thunks.find_symbols_in_ast-Tuple{Any}","page":"Home","title":"Thunks.find_symbols_in_ast","text":"Walk an AST and find all unique symbols.\n\n\n\n\n\n","category":"method"},{"location":"#Thunks.maybe_thunk-Tuple{Any, Any}","page":"Home","title":"Thunks.maybe_thunk","text":"Return true if symbol could be assigned to a Thunk.\n\n\n\n\n\n","category":"method"},{"location":"#Thunks.reify-Tuple{Thunk}","page":"Home","title":"Thunks.reify","text":"reify(thunk::Thunk)\nreify(value::Any)\n\nReify a thunk into a value.\n\nIn other words, compute the value of the expression.\n\nWe walk through the thunk's arguments and keywords, recursively evaluating each one, and then evaluating the thunk's function with the evaluated arguments.\n\n\n\n\n\n","category":"method"},{"location":"#Thunks.thunkify-Tuple{Any}","page":"Home","title":"Thunks.thunkify","text":"Turn expression into a thunk. Supports :call, :(=), :block.\n\nNot intended for public usage.\n\n\n\n\n\n","category":"method"},{"location":"#Thunks.@thunk-Tuple{Any}","page":"Home","title":"Thunks.@thunk","text":"Creat thunk from arbitrary Julia expressions.\n\nThis doesn't work as for eg:\n\njulia> @thunk y = maybe_add1(2; add1=false)\nnew = :((((add1, maybe_add1, y)->begin\n                 #= /home/tyler/.julia/dev/Thunks/src/macros.jl:135 =#\n                 y = maybe_add1(2; add1 = false)\n             end))(add1, maybe_add1, y))\n\nsince add1 is not defined\n\n\n\n\n\n","category":"macro"}]
}
